"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Quest = void 0;
const constants_1 = require("../../utils/constants");
const helperFunctions_1 = require("../../utils/helperFunctions");
class Quest {
    constructor(questSdk) {
        this.questSdk = questSdk;
    }
    getAllQuests({ category, limit, page } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `/quests`;
                const queryParams = Object.assign(Object.assign(Object.assign(Object.assign({}, (category && { category })), (limit && { limit })), (page && { page })), options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getAllQuestsForEntity({ category, limit, page, entityId } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/quests`;
                const queryParams = Object.assign(Object.assign(Object.assign(Object.assign({}, (category && { category })), (limit && { limit })), (page && { page })), options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getQuestDetails({ questId, detailsPage, entityId, prefixBadgeIpfs }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, userId, token, questId });
                const url = `/entities/${defaultEntityId}/quests/${questId}`;
                const queryParams = Object.assign(Object.assign(Object.assign({ userId }, (prefixBadgeIpfs && { prefixBadgeIpfs })), (detailsPage && { detailsPage })), options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getQuestSummary({ questId, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, userId, token, questId });
                const url = `/entities/${defaultEntityId}/quests/${questId}/summary`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    createQuest({ title, eligibilityCriterias, rewards, description, endsAt, entityId, hasReferral, imageURL, isPrivate, referralXP, theme, dependentQuestIDs, isDependentCriterias, isMetricQuest, }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, userId, token, title, eligibilityCriterias, rewards });
                const url = `/entities/${defaultEntityId}/quests`;
                const body = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ title,
                    eligibilityCriterias,
                    rewards }, (description && { description })), (imageURL && { imageURL })), (endsAt && { endsAt })), (hasReferral && { hasReferral })), (referralXP && { referralXP })), (theme && { theme })), (isPrivate && { isPrivate })), (dependentQuestIDs && { dependentQuestIDs })), (isDependentCriterias && { isDependentCriterias })), (isMetricQuest && { isMetricQuest })), options === null || options === void 0 ? void 0 : options._body);
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    updateQuest({ questId, title, description, eligibilityCriterias, endsAt, entityId, hasReferral, imageURL, isPrivate, referralXP, rewards, theme, rewardIdsToDelete, eligibilityCriteriaIdsToDelete, isMetricQuest, }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, userId, token, questId });
                const url = `/entities/${defaultEntityId}/quests/${questId}/update`;
                const body = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (title && { title })), (description && { description })), (eligibilityCriterias && { eligibilityCriterias })), (endsAt && { endsAt })), (entityId && { entityId })), (hasReferral && { hasReferral })), (imageURL && { imageURL })), (isPrivate && { isPrivate })), (referralXP && { referralXP })), (rewards && { rewards })), (theme && { theme })), (rewardIdsToDelete && { rewardIdsToDelete })), (eligibilityCriteriaIdsToDelete && { eligibilityCriteriaIdsToDelete })), (isMetricQuest && { isMetricQuest })), options === null || options === void 0 ? void 0 : options._body);
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                if (Object.keys(body).length === 0) {
                    throw new Error("Invalid request. Update atleast one field");
                }
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    deleteQuest({ questId, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, questId, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/quests/${questId}/delete`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    body: options === null || options === void 0 ? void 0 : options._body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    verifyQuestCriteriaForAUser({ questId, criteriaId, entityId, answer }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, questId, entityId: defaultEntityId, criteriaId });
                const url = `/entities/${defaultEntityId}/quests/${questId}/verify`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const body = Object.assign(Object.assign({ criteriaId }, (answer && { answer })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    verifyMultipleQuestCriteriaForAUser({ questId, entityId, criterias, referralCode, session }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, questId, entityId: defaultEntityId, criterias });
                const url = `/entities/${defaultEntityId}/quests/${questId}/verify-all`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const body = Object.assign(Object.assign(Object.assign({ criterias }, (referralCode && { referralCode })), (session && { session })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    claimQuestRewards({ questId, referralCode, userIds, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, questId, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/quests/${questId}/claim`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const body = Object.assign(Object.assign(Object.assign({ userId }, (referralCode && { referralCode })), (userIds && { userIds })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    claimMultipleQuestRewards({ questIds, referralCode, entityId, addToDynamicNFT }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, questIds, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/quests/claim-multiple`;
                const body = Object.assign(Object.assign(Object.assign({ questIds,
                    userId }, (referralCode && { referralCode })), (addToDynamicNFT && { addToDynamicNFT })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getOrSetNewReferralCodeForQuestAndUser({ questId, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, questId, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/quests/${questId}/users/${userId}/referralcode`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getReferralLeaderboard({ questId, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, questId, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/quests/${questId}/referraldashboard`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getQuestSubmissions({ questId, parentEntityId, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, questId, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/quests/${questId}/submissions`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getMultipleQuestDetails({ entityId, limit, detailsPage, page } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/multiple-quests`;
                const queryParams = Object.assign(Object.assign(Object.assign(Object.assign({ userId }, (detailsPage && { detailsPage })), (page && { page })), (limit && { limit })), options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    method: constants_1.HTTP_METHOD.GET,
                    url,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    createMetricQuest({ title, description, metric, rewards, autoClaimRewards, repeatRewardsBasedOnMetricCount, endsAt, entityId, metadata, priority, }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({
                    userId,
                    token,
                    entityId: defaultEntityId,
                    title,
                    metric,
                    rewards,
                    autoClaimRewards,
                    repeatRewardsBasedOnMetricCount,
                });
                const url = `/entities/${defaultEntityId}/metric-quests`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const body = Object.assign(Object.assign(Object.assign({ title,
                    description,
                    metric,
                    rewards,
                    autoClaimRewards,
                    repeatRewardsBasedOnMetricCount,
                    endsAt }, (metadata && { metadata })), (priority && { priority })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getMetricQuestDetails({ questId, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, entityId: defaultEntityId, questId });
                const url = `/entities/${defaultEntityId}/metric-quests/${questId}`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
}
exports.Quest = Quest;
