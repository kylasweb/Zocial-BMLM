"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Entity = void 0;
const constants_1 = require("../../utils/constants");
const helperFunctions_1 = require("../../utils/helperFunctions");
class Entity {
    constructor(questSdk) {
        this.questSdk = questSdk;
    }
    createNewEntity({ name, contracts, openseaSlug, description, chainSource = "OFF_CHAIN", isPrivate, decreaseCreditsAt, decreaseCreditsFrom, website, imageUrl, bannerUrl, entityURLAlias, parentEntityId, category, forUserId, }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const entityAuthenticationToken = this.questSdk.getEntityAuthenticationToken();
                const entityId = parentEntityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ name });
                if (!entityAuthenticationToken && (!userId || !token)) {
                    throw new Error("Either the entityAuthenticationToken or the user needs to be set");
                }
                if (entityAuthenticationToken) {
                    parentEntityId = entityId;
                    if (!parentEntityId) {
                        throw new Error("Either parentEntityId needs to be passed or entityId needs to be added to base config for entityAuthenticationToken");
                    }
                    this.questSdk.setEntityId({ entityId: parentEntityId });
                }
                const url = `/entities`;
                const queryParams = Object.assign({ userId: forUserId || userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const body = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name,
                    chainSource }, (contracts && { contracts })), (openseaSlug && { openseaSlug })), (description && { description })), (isPrivate && { isPrivate })), (decreaseCreditsAt && { decreaseCreditsAt })), (decreaseCreditsFrom && { decreaseCreditsFrom })), (website && { website })), (imageUrl && { imageUrl })), (bannerUrl && { bannerUrl })), (entityURLAlias && { entityURLAlias })), (parentEntityId && { parentEntityId })), (category && { category })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    addNewCustomEntityId({ customPlatformId, customPlatformName, entityId, accessToken, expiresIn, link, name, refreshToken, username, }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, customPlatformName, customPlatformId });
                if (this.questSdk.getEntityAuthenticationToken() === undefined) {
                    (0, helperFunctions_1.validateParams)({ userId, token });
                }
                const url = `/entities/${defaultEntityId}/custom-ids`;
                const body = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ customPlatformId,
                    customPlatformName }, (accessToken && { accessToken })), (expiresIn && { expiresIn })), (link && { link })), (name && { name })), (refreshToken && { refreshToken })), (username && { username })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getAllEntities({ page, limit, category } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `/entities`;
                const queryParams = Object.assign(Object.assign(Object.assign(Object.assign({}, (page && { page })), (limit && { limit })), (category && { category })), options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({ url, method: constants_1.HTTP_METHOD.GET, queryParams, headers: options === null || options === void 0 ? void 0 : options._headers });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getEntityInfo({ entityId } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getEntityIdForAlias({ alias }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                (0, helperFunctions_1.validateParams)({ alias });
                const url = `/entities/alias/${alias}/id`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getEntityIdForCustomEntityId({ customEntityId, platform, recordType }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                (0, helperFunctions_1.validateParams)({ customEntityId, platform, recordType });
                const url = `/entities/custom-ids/${customEntityId}/id`;
                const queryParams = Object.assign({ platform,
                    recordType }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams: queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    updateEntity({ entityId, name, description, isPrivate, decreaseCreditsAt, decreaseCreditsFrom, website, imageUrl, bannerUrl, entityURLAlias, }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId });
                if (this.questSdk.getEntityAuthenticationToken() === undefined) {
                    (0, helperFunctions_1.validateParams)({ userId, token });
                }
                const url = `/entities/${defaultEntityId}/update`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const body = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (name && { name })), (description && { description })), (isPrivate && { isPrivate })), (decreaseCreditsAt && { decreaseCreditsAt })), (decreaseCreditsFrom && { decreaseCreditsFrom })), (website && { website })), (imageUrl && { imageUrl })), (bannerUrl && { bannerUrl })), (entityURLAlias && { entityURLAlias })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    updateEntityTheme({ theme, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, theme, userId, token });
                const url = `/entities/${defaultEntityId}/update-theme`;
                const body = Object.assign({ theme }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getEntityTheme({ entityId } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/get-theme`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    updateEntityPlan({ entityId, product }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, product, userId, token });
                const url = `/entities/${defaultEntityId}/update-plan`;
                const body = Object.assign({ product }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getUsersOfEntity({ entityId } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, userId });
                if (this.questSdk.getEntityAuthenticationToken() === undefined) {
                    (0, helperFunctions_1.validateParams)({ token });
                }
                const url = `/entities/${defaultEntityId}/users`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({ url, method: constants_1.HTTP_METHOD.GET, queryParams, headers: options === null || options === void 0 ? void 0 : options._headers });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    manuallyAddUsersToEntity({ userIds, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, userIds, userId, token });
                const url = `/entities/${defaultEntityId}/force-add`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const body = Object.assign({ userIds }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getAllAdmins({ entityId, lessDetails } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, userId, token });
                const url = `/entities/${defaultEntityId}/admins`;
                const queryParams = Object.assign(Object.assign({}, (lessDetails && { lessDetails })), options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams: queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    removeAdmin({ userId, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const user = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, userId });
                if (this.questSdk.getEntityAuthenticationToken() === undefined) {
                    (0, helperFunctions_1.validateParams)({ userId: user.userId, token: user.token });
                }
                const url = `/entities/${defaultEntityId}/remove-admin`;
                const body = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    addOrUpdateSocialTokens({ recordType, entityId, authClientId, authClientSecret, apiKey, apiSecret, authorizationToken, apiHost, }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, recordType, userId });
                if (this.questSdk.getEntityAuthenticationToken() === undefined) {
                    (0, helperFunctions_1.validateParams)({ token });
                }
                const url = `/entities/${defaultEntityId}/users/${userId}/social-tokens`;
                const body = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (authClientId && { authClientId })), (authClientSecret && { authClientSecret })), (apiKey && { apiKey })), (apiSecret && { apiSecret })), (recordType && { recordType })), (authorizationToken && { authorizationToken })), (apiHost && { apiHost })), options === null || options === void 0 ? void 0 : options._body);
                if (Object.keys(body).length === 0) {
                    throw new Error("Invalid request. Atleast one token needs to be passed");
                }
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getSocialTokens({ recordType, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, recordType, userId });
                if (this.questSdk.getEntityAuthenticationToken() === undefined) {
                    (0, helperFunctions_1.validateParams)({ token });
                }
                const url = `/entities/${defaultEntityId}/users/${userId}/social-tokens`;
                const queryParams = Object.assign({ recordType }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({ url, method: constants_1.HTTP_METHOD.GET, queryParams, headers: options === null || options === void 0 ? void 0 : options._headers });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    approveEntityCreation({ baseName, baseSymbol, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ entityId, userId, token });
                const url = `/admin/entities/approve`;
                const body = Object.assign(Object.assign(Object.assign({ entityId }, (baseName && { baseName })), (baseSymbol && { baseSymbol })), options === null || options === void 0 ? void 0 : options._body);
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getAllPendingEntities(options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token });
                const url = `/admin/entities/pending`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    addAdminToEntity({ email, name, entityId, role }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, email, name });
                if (this.questSdk.getEntityAuthenticationToken() === undefined) {
                    (0, helperFunctions_1.validateParams)({ userId, token });
                }
                const url = `/entities/${defaultEntityId}/invite`;
                const body = Object.assign({ email,
                    name }, (role && { role }));
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getOrGenerateNewAPIKey({ entityId } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId });
                if (this.questSdk.getEntityAuthenticationToken() === undefined) {
                    (0, helperFunctions_1.validateParams)({ userId, token });
                }
                const url = `/entities/${defaultEntityId}/keys`;
                const queryParams = Object.assign({ userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
}
exports.Entity = Entity;
