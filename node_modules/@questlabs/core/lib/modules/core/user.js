"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const helperFunctions_1 = require("../../utils/helperFunctions");
const constants_1 = require("../../utils/constants");
class User {
    constructor(questSdk) {
        this.questSdk = questSdk;
    }
    createNewCustomUser({ customPlatform, customUserId, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ customPlatform, customUserId, entityId: defaultEntityId });
                const url = `/users/custom-ids`;
                const body = Object.assign({ customPlatform,
                    customUserId, entityId: defaultEntityId }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getUserDetailsForUserId({ forUserId } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token });
                const queryParams = Object.assign({ userId: forUserId || userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const url = `/users/${forUserId || userId}`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getUserDetailsForEmail({ email }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ email, userId, token });
                const url = `/users/email/${email}`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getUserDetailsForWalletAddress({ walletAddress }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token, walletAddress });
                const url = `/users/address/${walletAddress}`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getConnectedUserSocials({ entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/users/${userId}/connected-socials`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    entitesForUser({ page, limit } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token, page, limit });
                const url = `/users/${userId}/entities`;
                const queryParams = Object.assign({ page, limit }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({ url, method: constants_1.HTTP_METHOD.GET, queryParams, headers: options === null || options === void 0 ? void 0 : options._headers });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getAdminEntitiesForUser({ parentEntityId } = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token });
                const url = `/users/${userId}/admin-entities`;
                const queryParams = Object.assign(Object.assign({}, (parentEntityId && { parentEntityId })), options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({ url, method: constants_1.HTTP_METHOD.GET, queryParams, headers: options === null || options === void 0 ? void 0 : options._headers });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    setSelectedAdminEntityId({ entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, entityId: defaultEntityId });
                const url = `/users/${defaultEntityId}/admin-entities`;
                const body = Object.assign({ entityId }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    setUserInfo({ name, imageUrl, bannerUrl, location, expertise, goals, interests, about, currentWork, funFacts, role, sector, }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token });
                const url = `/users/${userId}`;
                const body = Object.assign({ name,
                    imageUrl,
                    bannerUrl,
                    location,
                    expertise,
                    goals,
                    interests,
                    about,
                    currentWork,
                    funFacts,
                    role,
                    sector }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    sendOtpEmail({ email, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ email, entityId: defaultEntityId });
                const url = `/users/email-login/send-otp`;
                const body = Object.assign({ email, entityId: defaultEntityId }, options === null || options === void 0 ? void 0 : options._body);
                const queryParams = Object.assign({ entityId: defaultEntityId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    verifyOtpEmail({ email, entityId, otp, name }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ email, entityId: defaultEntityId, otp });
                const url = `/users/email-login/verify-otp`;
                const body = Object.assign(Object.assign({ email, entityId: defaultEntityId, otp }, (name && { name })), options === null || options === void 0 ? void 0 : options._body);
                const response = yield this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
                if (response.success === true && response.userId && response.token) {
                    this.questSdk.setUser({
                        userId: response.userId,
                        token: response.token,
                    });
                }
                return response;
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    loginWithGoogle({ code, redirectUri, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                (0, helperFunctions_1.validateParams)({ code, redirectUri, entityId });
                const url = `/users/google/login`;
                const body = Object.assign({ code, redirectUri, entityId }, options === null || options === void 0 ? void 0 : options._body);
                const response = yield this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
                if (response.success === true && response.userId && response.token) {
                    this.questSdk.setUser({
                        userId: response.userId,
                        token: response.token,
                    });
                }
                return response;
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    loginWithWallet({ entityId, walletAddress, signature, token }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                (0, helperFunctions_1.validateParams)({ entityId, walletAddress, signature, token });
                const url = `/users/wallet/login`;
                const body = Object.assign({ entityId, walletAddress, signature, token }, options === null || options === void 0 ? void 0 : options._body);
                const response = yield this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
                if (response.success === true && response.userId && response.token) {
                    this.questSdk.setUser({
                        userId: response.userId,
                        token: response.token,
                    });
                }
                return response;
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    connectWallet({ entityId, walletAddress, signature, token, userId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                (0, helperFunctions_1.validateParams)({ entityId, walletAddress, signature, token, userId });
                const url = `/users/${userId}/wallet-connect`;
                const body = Object.assign({ entityId, walletAddress, signature, token }, options === null || options === void 0 ? void 0 : options._body);
                const queryParams = Object.assign({}, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    loginWithExternalUserId({ externalUserId, entityId, email, walletAddress, name, imageUrl }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, externalUserId });
                const url = `/users/external/login`;
                const body = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ externalUserId, entityId: defaultEntityId }, (email && { email })), (walletAddress && { walletAddress })), (name && { name })), (imageUrl && { imageUrl })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    loginWithExternalUserIdEncrypted({ externalUserId, entityId, email, walletAddress }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                const { apiKey, apiSecret } = this.questSdk.getApiKeys();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, externalUserId, apiSecret });
                const dataToEncrypt = Object.assign(Object.assign(Object.assign({ externalUserId, entityId: defaultEntityId }, (email && { email })), (walletAddress && { walletAddress })), { apiKey });
                const encryptedData = yield this.encryptData(JSON.stringify(dataToEncrypt), apiSecret);
                if (!encryptedData) {
                    throw new Error('Encryption failed');
                }
                const url = `/users/external/login/encrypted`;
                const body = Object.assign({ entityId: defaultEntityId, encryptedData }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    refreshUserToken({ refreshToken, entityId }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, refreshToken, token, userId });
                const url = `/entities/${defaultEntityId}/users/${userId}/refresh-token`;
                const body = Object.assign({ refreshToken }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    encryptData(data, secretKey) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const encoder = new TextEncoder();
                const iv = crypto.getRandomValues(new Uint8Array(16));
                const hashedKey = yield crypto.subtle.digest({ name: "SHA-256" }, encoder.encode(secretKey));
                const key = yield crypto.subtle.importKey("raw", hashedKey, { name: "AES-CBC", length: 256 }, false, [
                    "encrypt",
                ]);
                const encrypted = yield crypto.subtle.encrypt({ name: "AES-CBC", iv }, key, encoder.encode(data));
                return {
                    iv: Array.from(iv)
                        .map((b) => b.toString(16).padStart(2, "0"))
                        .join(""),
                    encryptedData: Array.from(new Uint8Array(encrypted))
                        .map((b) => b.toString(16).padStart(2, "0"))
                        .join(""),
                };
            }
            catch (error) {
                throw new error;
            }
        });
    }
}
exports.User = User;
